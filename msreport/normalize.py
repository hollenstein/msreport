from __future__ import annotations
import abc
import itertools
from typing import Callable, Iterable

import numpy as np
import pandas as pd
import statsmodels.nonparametric.smoothers_lowess

import msreport.helper


class BaseSampleNormalizer(abc.ABC):
    """Base class for all sample normalizers."""

    @abc.abstractmethod
    def fit(self, table: pd.DataFrame) -> BaseSampleNormalizer:
        pass

    @abc.abstractmethod
    def is_fitted(self) -> bool:
        pass

    @abc.abstractmethod
    def transform(self, sample: str, values: Iterable) -> Iterable:
        pass

    @abc.abstractmethod
    def transform_table(self, table: pd.DataFrame) -> pd.DataFrame:
        pass


class FixedValueNormalizer(BaseSampleNormalizer):
    """Normalization by a constant normalization factor for each sample.

    Expects log transformed intensity values.
    """

    def __init__(self, center_function: Callable, comparison: str):
        """Initializes the FixedValueNormalizer.

        Args:
            center_function: A function that accepts a sequence of values and
                returns a center value such as the median.
            comparison: Must be "paired" or "reference". When "paired" is specified
                the normalization values are first calculated for each column pair. Then
                an optimal normalization value for each column is calculated by solving
                a matrix of linear equations of the column pair values with least
                squares. When "reference" is selected, a pseudo-reference sample is
                generated by calculating the mean value for each row. Only rows with
                valid values in all columns are used. Normalization values are then
                calculated by comparing each column to the pseudo-reference sample.
        """
        if comparison not in ["paired", "reference"]:
            raise ValueError(
                f'"comparison" = {comparison} not allowed. '
                'Must be either "paired" or "reference".'
            )
        self._comparison_mode = comparison
        self._fit_function = center_function
        self._sample_fits = None

    def fit(self, table: pd.DataFrame) -> BaseSampleNormalizer:
        """Fits the FixedValueNormalizer.

        Args:
            table: Dataframe used to calculate normalization values for each column.
                The normalization values are stored with the column names.

        Returns:
            Returns the instance itself.
        """
        if self._comparison_mode == "paired":
            self._fit_with_paired_samples(table)
        elif self._comparison_mode == "reference":
            self._fit_with_pseudo_reference(table)
        return self

    def is_fitted(self) -> bool:
        """Returns True if the FixedValueNormalizer has been fitted."""
        return self._sample_fits is not None

    def transform(self, sample: str, values: Iterable) -> np.ndarray:
        """Applies a fixed value normalization to the 'values'.

        Args:
            sample: Use the normalization value calculated for the specified 'sample'.
                Must correspond to one of the column names from the table that was used
                for the fitting.
            values: The data to normalize.

        Returns:
            Transformed array.
        """
        data = np.array(values, dtype=float)
        mask = np.isfinite(data)
        data[mask] = data[mask] - self._sample_fits[sample]
        return data

    def transform_table(self, table: pd.DataFrame) -> pd.DataFrame:
        """Applies a fixed value normalization to each column of the table.

        Args:
            table: The data to normalize. Each column name must correspond to a column
                name from the table that was used for the fitting.

        Returns:
            Transformed dataframe.
        """
        _table = table.copy()
        for sample in table.columns:
            _table[sample] = self.transform(sample, _table[sample])
        return _table

    def _fit_with_paired_samples(self, table: pd.DataFrame) -> None:
        """Fits the FixedValueNormalizer by doing pair-wise column comparisons.

        Normalization values are first calculated for each column pair. Then an optimal
        normalization value for each column is calculated by solving a matrix of linear
        equations of the column pair values with least squares. The individual
        normalization values are stored in a dictionary with the column names as keys.

        Args:
            table: Dataframe used to calculate normalization values for each column.
        """
        samples = table.columns.tolist()
        num_samples = len(samples)
        sample_combinations = list(itertools.combinations(range(num_samples), 2))
        ratio_table = np.full((num_samples, num_samples), np.nan)
        for i, j in sample_combinations:
            ratios = table[samples[i]] - table[samples[j]]
            ratios = ratios[np.isfinite(ratios)]
            center_value = self._fit_function(ratios)
            ratio_table[i, j] = center_value
        profile = msreport.helper.solve_ratio_matrix(ratio_table)
        self._sample_fits = dict(zip(samples, profile))

    def _fit_with_pseudo_reference(self, table: pd.DataFrame) -> None:
        """Fits the FixedValueNormalizer by comparing columns to a pseudo-reference.

        First, a pseudo-reference samples is generated by calculating the mean value for
        each row. Only rows with valid values in all columns are used. Normalization
        values are then calculated by comparing each column to the pseudo-reference
        sample. The individual normalization values are stored in a dictionary with the
        column names as keys.

        Args:
            table: Dataframe used to calculate normalization values for each column.
        """

        ref_mask = table.isna().sum(axis=1) == 0
        ref_values = table[ref_mask].mean(axis=1)
        samples = table.columns.tolist()

        self._sample_fits = {}
        for sample in samples:
            sample_values = table.loc[ref_mask, sample]
            sample_fit = self._fit_function(sample_values - ref_values)
            self._sample_fits[sample] = sample_fit


class ValueDependentNormalizer(BaseSampleNormalizer):
    """Normalization with a value dependent fit for each sample.

    Expects log transformed intensity values.
    """

    def __init__(self, fit_function: Callable):
        """Initializes the ValueDependentNormalizer.

        Args:
            fit_function: A function that accepts a sequence of values and returns a
                numpy array with two columns. The first column must contain the values
                and the second column the associated deviations.
        """
        self._sample_fits = None
        self._fit_function = fit_function

    def fit(self, table: pd.DataFrame) -> BaseSampleNormalizer:
        """Fits the ValueDependentNormalizer.

        Args:
            table: Dataframe used to calculate normalization arrays for each column.

        Returns:
            Returns the instance itself.
        """
        self._fit_with_pseudo_reference(table)
        return self

    def is_fitted(self) -> bool:
        """Returns True if the ValueDependentNormalizer has been fitted."""
        return self._sample_fits is not None

    def transform(self, sample: str, values: Iterable) -> np.ndarray:
        """Applies a value dependent normalization to the 'values'.

        Args:
            sample: Use the normalization arrays calculated for the specified 'sample'.
                Must correspond to one of the column names from the table that was used
                for the fitting.
            values: The data to normalize.

        Returns:
            Transformed array.
        """
        data = np.array(values, dtype=float)
        mask = np.isfinite(data)

        sample_fit = self._sample_fits[sample]
        fit_values, fit_deviations = [np.array(i) for i in zip(*sample_fit)]
        data[mask] = data[mask] - np.interp(data[mask], fit_values, fit_deviations)
        return data

    def transform_table(self, table: pd.DataFrame) -> pd.DataFrame:
        """Applies a value dependent normalization to each column of the table.

        Args:
            table: The data to normalize. Each column name must correspond to a column
                name from the table that was used for the fitting.

        Returns:
            Transformed dataframe.
        """
        _table = table.copy()
        for sample in table.columns:
            _table[sample] = self.transform(sample, _table[sample])
        return _table

    def _fit_with_pseudo_reference(self, table: pd.DataFrame) -> None:
        """Fits the FixedValueNormalizer by comparing columns to a pseudo-reference.

        First, a pseudo-reference samples is generated by calculating the mean value for
        each row. Only rows with valid values in all columns are used. Normalization
        arrays are then calculated by comparing each column to the pseudo-reference
        sample. The individual normalization arrays are stored in a dictionary with the
        column names as keys.

        Args:
            table: Dataframe used to calculate normalization values for each column.
        """
        ref_mask = table.isna().sum(axis=1) == 0
        ref_values = table[ref_mask].mean(axis=1)
        samples = table.columns.tolist()

        self._sample_fits = {}
        for sample in samples:
            sample_values = table.loc[ref_mask, sample]
            sample_fit = self._fit_function(sample_values, ref_values)
            self._sample_fits[sample] = sample_fit


class MedianNormalizer(FixedValueNormalizer):
    """A FixedValueNormalizer that uses the median as the fitting function.

    Use MedianNormalizer.fit(table: pd.DataFrame) to fit the normalizer, and then
    MedianNormalizer.transform(sample: str, values: Iterable) or
    MedianNormalizer.transform_table(table: pd.DataFrame) with the fitted normalizer
    to apply the normalization.
    """

    def __init__(self):
        """Initializes the MedianNormalizer."""
        super(MedianNormalizer, self).__init__(
            center_function=np.median, comparison="paired"
        )


class ModeNormalizer(FixedValueNormalizer):
    """A FixedValueNormalizer that uses the mode as the fitting function.

    Use ModeNormalizer.fit(table: pd.DataFrame) to fit the normalizer, and then
    ModeNormalizer.transform(sample: str, values: Iterable) or
    ModeNormalizer.transform_table(table: pd.DataFrame) with the fitted normalizer
    to apply the normalization.
    """

    def __init__(self):
        """Initializes the ModeNormalizer."""
        super(ModeNormalizer, self).__init__(
            center_function=msreport.helper.mode, comparison="paired"
        )


class LowessNormalizer(ValueDependentNormalizer):
    """A ValueDependentNormalizer that uses lowess as the fitting function.

    Use LowessNormalizer.fit(table: pd.DataFrame) to fit the normalizer, and then
    LowessNormalizer.transform(sample: str, values: Iterable) or
    LowessNormalizer.transform_table(table: pd.DataFrame) with the fitted normalizer
    to apply the normalization.
    """

    def __init__(self):
        """Initializes the LowessNormalizer."""
        super(LowessNormalizer, self).__init__(fit_function=_value_dependent_fit_lowess)


def _value_dependent_fit_lowess(
    values: np.ndarray,
    reference_values: np.ndarray,
    delta_span_percentage: float = 0.05,
    iterations: int = 5,
) -> np.ndarray:
    """Calculates estimated deviations between values and reference_values using lowess.

    Args:
        values: The y-values of the observed points
        reference_values: Used to calcualte the x-values of the observed points, as
            'values' - 'reference_values'.
        delta_span_percentage: Distance within which to use linear-interpolation
            instead of weighted regression, as a percentage of the data span.
        iterations: The number of residual-based reweightings to perform

    Returns:
        A numpy array with two columns. The first column contains the sorted 'values'
        and the second column the associated estimated deviation values from the
        reference.
    """
    delta = (reference_values.max() - reference_values.min()) * delta_span_percentage
    deviations = values - reference_values
    return statsmodels.nonparametric.smoothers_lowess.lowess(
        deviations, values, delta=delta, it=iterations
    )
