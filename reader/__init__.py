""" Module for reading and homogenizing result tables from various MS analysis
tools. Currently MaxQuant and FragPipe protein tables are fully supported, and
ion and peptide tables are partly supported.

New or changed column names:
- Spectral count "sample name"
- Unique spectral count "sample name"
- Total spectral count "sample name"
- LFQ intensity "sample name"
- Intensity "sample name"
- Total peptides
- Representative protein
- Leading proteins

Todos:
- Add full support for ion (evidence) and peptide tables


FP reader:

For LFQ the most relevant files are combined_protein.tsv, combined_ion.tsv
For TMT the relevant files are protein.tsv, psm.tsv (might be in folders)
"""


from collections import OrderedDict
import pandas as pd
import os
import helper


class ResultReader():
    """ Base Reader class, is by itself not functional. """
    filenames_default: dict[str, str]
    sample_column_tags: list[str]
    column_mapping: dict[str, str]
    column_tag_mapping: OrderedDict[str, str]
    column_dtypes: dict[str: str]

    def _read_file(self, which: str) -> pd.DataFrame:
        """ Read a result table from the data_directory

        Args:
            which: Used to lookup the file name in self.filenames
        """
        filepath = os.path.join(self.data_directory, self.filenames[which])
        df = pd.read_csv(filepath, sep='\t', dtype=self.column_dtypes)
        for column, dtype in self.column_dtypes.items():
            if column in df and dtype == 'str':
                df[column] = df[column].fillna('')
        return df

    def _rename_columns(self, df: pd.DataFrame,
                        prefixed: bool) -> pd.DataFrame:
        """ Rename columns to match a common format between programs.

        First rename columns according to self.column_mapping. Next, replace
        tags in columns according to self.column_tag_mapping. Then, for
        columns containing sample names, rearrange sample names and the column
        tag.
        """
        df = df.copy()
        df.rename(columns=self.column_mapping, inplace=True)
        for old_tag, new_tag in self.column_tag_mapping.items():
            df = _replace_column_tag(df, old_tag, new_tag)

        for tag in self.sample_column_tags:
            if tag in self.column_tag_mapping:
                tag = self.column_tag_mapping[tag]
            df = _rearrange_column_tag(df, tag, prefixed)
        return df


class MQReader(ResultReader):
    """ Import and preprocess MaxQuant result files.

    Attributes:
        filenames_default: (class attribute) Look up of filenames for the
            result files generated by MaxQuant.
        sample_column_tags: (class attribute) Column tags for which an
            additional column is present per sample.
        column_mapping: (class attribute) Replace old with new column names.
        column_tag_mapping: (class attribute) Mapping of 'Old substring' to
            'New substring' that will be replaced in column names.

        data_directory (str): Location of the MaxQuant 'txt' folder
        contamination_tag (str): Substring present in protein IDs to identify
            them as potential contaminants.
    """
    filenames_default: dict[str, str] = {
        'proteins': 'proteinGroups.txt',
        'peptides': 'peptides.txt',
        'ions': 'evidence.txt'
    }
    sample_column_tags: list[str] = [
        'LFQ intensity', 'Intensity', 'iBAQ',
        'MS/MS count', 'Sequence coverage',
    ]
    column_mapping: dict[str, str] = dict([
        ('Peptides', 'Total peptides'),
    ])
    column_tag_mapping: OrderedDict[str, str] = OrderedDict([
        ('MS/MS count', 'Spectral count'),
    ])
    column_dtypes = {'Fasta headers': 'str'}

    def __init__(self, directory: str, isobar: bool = False,
                 contaminant_tag: str = 'CON_') -> None:
        """
        Args:
            directory: Location of the MaxQuant 'txt' folder
            isobar: True if quantification strategy was TMT, iTRAQ or similar
            contaminant_tag: Prefix of Protein ID entries to identify
                contaminations

        Attributes:
            data_directory: Location of the MaxQuant 'txt' folder
            filenames: Look up of filenames generated by MaxQuant
        """
        self.data_directory: str = directory
        self.filenames: dict[str, str] = self.filenames_default
        self._isobar: bool = isobar
        self._contaminant_tag: str = contaminant_tag

    def import_proteins(self,
                        rename_columns: bool = True,
                        drop_decoy: bool = True,
                        drop_idbysite: bool = True,
                        column_tags_prefixed: bool = True,
                        special_proteins: list[str] = []) -> pd.DataFrame:
        """ Read and process 'proteinGroups.txt' file """
        df = self._read_file('proteins')
        if drop_decoy:
            df = self._drop_decoy(df)
        if drop_idbysite:
            df = self._drop_idbysite(df)
        if rename_columns:
            df = self._rename_columns(df, column_tags_prefixed)
        df = self._rearrange_proteins(df, special_proteins)
        return df

    def import_peptides(self, drop_decoy: bool = True,
                        column_tags_prefixed: bool = True) -> pd.DataFrame:
        """ Read and process 'proteinGroups.txt' file """
        df = self._read_file('peptides')
        if drop_decoy:
            df = self._drop_decoy(df)
        df = self._rename_columns(df, column_tags_prefixed)
        return df

    def import_ions(self, drop_decoy: bool = True) -> pd.DataFrame:
        """ Read and process 'proteinGroups.txt' file """
        df = self._read_file('ions')
        if drop_decoy:
            df = self._drop_decoy(df)
        return df

    def _drop_decoy(self, df: pd.DataFrame) -> pd.DataFrame:
        """ Removes rows with '+' in the 'Reverse' column """
        return df.loc[df['Reverse'] != '+']

    def _drop_idbysite(self, df: pd.DataFrame) -> pd.DataFrame:
        """ Removes rows with '+' in the 'Only identified by site' column """
        return df.loc[df['Only identified by site'] != '+']

    def _rearrange_proteins(self, df: pd.DataFrame,
                            special_proteins: list[str] = []
                            ) -> pd.DataFrame:
        """ Adds two new protein columns to the protein dataframe.

        'Leading proteins' will contain all protein entries from the
        'Majority protein IDs' column that have the highest number of peptide
        in 'Peptide counts (all)'. Multiple protein entries are separated by
        ';'. Special proteins are listed first and Proteins containing the
        contamination tag are listed last. Afterwards proteins are sorted
        alphabetically ascending.

        'Representative protein' will contain only the first entry from the
        new 'Leading proteins' column.
        """
        sorting_tag_levels = {self._contaminant_tag: 1}
        sorting_tag_levels.update({p: -1 for p in special_proteins})

        leading_entry_names = []
        leading_protein_entries = []
        representative_entry_names = []
        representative_protein_entries = []
        for fasta_entry, count_entry in zip(df['Fasta headers'],
                                            df['Peptide counts (all)']):
            fastas = fasta_entry.split(';')
            counts = [int(i) for i in count_entry.split(';')]
            highest_count = max(counts)
            leading_fastas = [f for f, c in zip(fastas, counts)
                              if c >= highest_count]

            fastas, proteins, names = _sort_fasta_entries(
                leading_fastas, sorting_tag_levels
            )
            leading_protein_entries.append(';'.join(proteins))
            leading_entry_names.append(';'.join(names))
            representative_protein_entries.append(proteins[0])
            representative_entry_names.append(names[0])

        df = df.copy()
        df['Leading entry names'] = leading_entry_names
        df['Leading proteins'] = leading_protein_entries
        df['Representative entry name'] = representative_entry_names
        df['Representative protein'] = representative_protein_entries
        return df


class FPReader(ResultReader):
    """ Import and preprocess FragPipe result files.

    Attributes:
        filenames_default: (class attribute) Look up of filenames for the
            result files generated by FragPipe with LFQ quantification.
        filenames_isobar: (class attribute) Look up of filenames for the result
            files generated by FragPipe with isobaric quantification.
        sample_column_tags: (class attribute) Column tags for which
            an additional column is present per sample.
        column_mapping: (class attribute) Replace old with new column names.
        column_tag_mapping: (class attribute) Mapping of 'Old substring' to
            'New substring' that will be replaced in column names.

        data_directory (str): Location of the MaxQuant 'txt' folder
        contamination_tag (str): Substring present in protein IDs to identify
            them as potential contaminants.
    """

    filenames_default: dict[str, str] = {
        'proteins': 'combined_protein.tsv',
        'peptides': 'combined_peptide.tsv',
        'ions': 'combined_ion.tsv',
    }
    filenames_isobar: dict[str, str] = {
        'proteins': 'protein.tsv',
        'peptides': 'peptide.tsv',
        'ions': 'ion.tsv',
    }
    sample_column_tags: list[str] = [
        'Spectral Count', 'Unique Spectral Count', 'Total Spectral Count',
        'Intensity', 'MaxLFQ Intensity'
    ]
    column_mapping: dict[str, str] = dict([
        ('Combined Total Peptides', 'Total peptides'),  # From LFQ
        ('Total Peptides', 'Total peptides'),  # From TMT
    ])
    column_tag_mapping: OrderedDict[str, str] = OrderedDict([
        ('MaxLFQ Intensity', 'LFQ intensity'),
        ('Total Spectral Count', 'Total spectral count'),
        ('Unique Spectral Count', 'Unique spectral count'),
        ('Spectral Count', 'Spectral count'),
    ])
    column_dtypes = {'Indistinguishable Proteins': 'str'}

    def __init__(self, directory: str, isobar: bool = False,
                 contaminant_tag: str = 'contam_') -> None:
        """
        Args:
            directory: Location of the FragPipe result folder
            isobar: True if quantification strategy was TMT, iTRAQ or similar
            contaminant_tag: Prefix of Protein ID entries to identify
                contaminants

        Attributes:
            data_directory: Location of the FragPipe result folder
            filenames: Look up of filenames generated by FragPipe
        """
        self.data_directory: str = directory
        self._isobar: bool = isobar
        self._contaminant_tag: str = contaminant_tag
        if not isobar:
            self.filenames = self.filenames_default
        else:
            self.filenames = self.filenames_isobar

    def import_proteins(self, rename_columns: bool = True,
                        column_tags_prefixed: bool = True,
                        special_proteins: list[str] = []) -> pd.DataFrame:
        """ Read and process 'proteinGroups.txt' file """
        # Note that is is essential to rename column names before attempting
        # to rename sample columns, as the 'Intensity' substring is present in
        # multiple columns.
        """ Read and process 'proteinGroups.txt' file """
        df = self._read_file('proteins')
        if rename_columns:
            df = self._rename_columns(df, column_tags_prefixed)
        df = self._rearrange_proteins(df, special_proteins)
        return df

    def _rearrange_proteins(self, df: pd.DataFrame,
                            special_proteins: list[str] = []) -> pd.DataFrame:
        """ Adds two new protein columns to the protein dataframe.

        'Leading proteins' will contain all protein entries from the 'Protein'
        and 'Indistinguishable Proteins' columns. Since these columns contain
        the beginning of the fasta header, the protein id is extracted.
        Multiple protein entries are separated by ';'. Protein entries are
        sorted alphabetically ascending.

        'Representative protein' will contain only the first entry from the
        new 'Leading proteins' column.

        """
        sorting_tag_levels = {self._contaminant_tag: 1}
        sorting_tag_levels.update({p: -1 for p in special_proteins})

        leading_entry_names = []
        leading_protein_entries = []
        representative_entry_names = []
        representative_protein_entries = []
        for protein_entry, indist_protein_entry in zip(
                df['Protein'], df['Indistinguishable Proteins']):
            fasta_entries = [protein_entry]
            if indist_protein_entry:
                for fasta in indist_protein_entry.split(', '):
                    fasta_entries.append(fasta)

            fastas, proteins, names = _sort_fasta_entries(
                fasta_entries, sorting_tag_levels
            )
            leading_protein_entries.append(';'.join(proteins))
            leading_entry_names.append(';'.join(names))
            representative_protein_entries.append(proteins[0])
            representative_entry_names.append(names[0])

        df = df.copy()
        df['Leading entry names'] = leading_entry_names
        df['Leading proteins'] = leading_protein_entries
        df['Representative entry name'] = representative_entry_names
        df['Representative protein'] = representative_protein_entries

        return df


def extract_sample_names(df: pd.DataFrame, tag: str) -> list[str]:
    """ Extract sample names from columns containing the 'tag' """
    columns = helper.find_columns(df, tag)
    sample_names = _find_remaining_substrings(columns, tag)
    return sample_names


def _replace_column_tag(df: pd.DataFrame,
                        old_tag: str, new_tag: str) -> pd.DataFrame:
    """ Replace column substrings old_tag with new_tag """
    old_columns = helper.find_columns(df, old_tag)
    new_columns = [c.replace(old_tag, new_tag) for c in old_columns]
    mapping = dict(zip(old_columns, new_columns))
    return df.rename(columns=mapping, inplace=False)


def _rearrange_column_tag(df: pd.DataFrame, tag: str,
                          prefixed: bool) -> pd.DataFrame:
    """ Moves the column tag to the beginning or end of each column.

    Args:
        df: Rearrange columns in this DataFrame
        tag: A substring that when found in column names should be moved
            to the beginning or end of the column name
        prefixed: if true, the tag string is moved to the beginning of the
            new column names, else to the end.
    """
    old_columns = helper.find_columns(df, tag)
    new_columns = []
    for column_name in old_columns:
        column_name = column_name.replace(tag, '').strip()
        if prefixed:
            new_column_name = ' '.join([tag, column_name]).strip()
        else:
            new_column_name = ' '.join([column_name, tag]).strip()
        new_columns.append(new_column_name)
    column_lookup = dict(zip(old_columns, new_columns))
    df = df.rename(columns=column_lookup, inplace=False)
    return df


def _find_remaining_substrings(strings: list[str],
                               split_with: str) -> list[str]:
    """ Find the remaining part from several strings after splitting. """
    substrings = []
    for string in strings:
        substrings.extend([s.strip() for s in string.split(split_with)])
    # Remove empty entries
    substrings = sorted(set(filter(None, substrings)))
    return substrings


def _sort_fasta_entries(fasta_entries: list[str],
                        sorting_tag_levels: dict[str, int] = {}
                        ) -> list[list[str], list[str], list[str]]:
    """ Return sorted fasta headers, protein ids, entry names.

    Fasta headers are first sorted according to the sort level of each header
    in ascending order, and those with the same entries are sorted
    alphabetically according to the UniqueID of the fasta header. By default
    each fasta entry has a sort level of 0.

    Args:
        sorting_tag_levels: Mapping of tags to sort levels. If the tag string
            is present in the UniqueID entry of the fasta headers, the sort
            level of for this fasta header is set.

    Returns:
        sorted lists of [fasta headers, protein ids, entry names]
    """
    values = []
    for fasta in fasta_entries:
        if fasta.count('|') >= 2:
            protein = fasta.split('|')[1]
            name = fasta.split('|')[2].split(' ')[0]
        else:
            protein = fasta
            name = fasta
        sort_level = 0
        for tag, level in sorting_tag_levels.items():
            if tag in protein:
                sort_level = level
        values.append((sort_level, protein, fasta, name))
    values.sort()
    sort_levels, proteins, fastas, names = [list(v) for v in zip(*(values))]
    return fastas, proteins, names


if __name__ == '__main__':
    filedir = 'C:/Users/david.hollenstein/ucloud/python/QuantTable/tests/testdata/maxquant_results'
    protein_table = MQReader(filedir).import_proteins()
    peptide_table = MQReader(filedir).import_peptides()
    sample_names = extract_sample_names(protein_table, 'Intensity')

    filedir = 'C:/Users/david.hollenstein/ucloud/python/QuantTable/tests/testdata/fragpipe_results'
    protein_table = FPReader(filedir).import_proteins()
